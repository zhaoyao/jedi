{"name":"Jedi","body":"#Jedi\r\nJedi is a simple and small library for storing objects in redis. It uses [Jedis](http://github.com/xetorthio/jedis \"Jedis\") internally so it is fully compatible with Redis 2.0.0.\r\n\r\n**This project is not ready for production yet**.\r\n\r\n# It is not an orm framework\r\nSo it does not support orm features, like relation mappings, which [Johm](https://github.com/xetorthio/johm \"Johm\") provided.\r\n\r\n#Examples\r\n\r\nJedi works fine with simple java pojos, just use very small amount of annotations\r\n\r\n```java\r\npublic class Book {\r\n\r\n    @Id  \r\n    private Long id;\r\n    \r\n    private String author;\r\n    \r\n    private String title;\r\n    \r\n    private Date publishedAt;\r\n}\r\n```\r\n\r\n\r\nDone. Let's begin some crud staffs\r\n\r\n###Basic CRUD\r\n\r\n```java\r\n\r\n//initialize jedis pool\r\nJedisPool jedisPool = new JedisPool(\"localhost\", 6379);\r\nJedi jedi = new Jedi(jedisPool);\r\n\r\nBook book = new Book();\r\nbook.setTile(\"Harry Potter\");\r\nbook.setAutor(\"J.K.Rowling\");\r\njedi.save(book);\r\n\r\n// the generated redis hash will be { id: __auto_generated__, title: \"Harry Potter\", author: \"J.K.Rowling\" }\r\n\r\nassertNotNull(book.getId()); //auto id generation\r\nassertNotNull(jedi.get(Book.class, book.getId())); //ready for id lookup\r\n\r\nLong id = book.getId();\r\n\r\n//oh, we forgot to set the publish date\r\nbook.setPublishedAt(new Date());\r\njedi.update(book);\r\n\r\n// the redis hash will be updated to { id: __auto_generated__, title: \"Harry Potter\", author: \"J.K.Rowling\", publishedAt: __epoch__ }\r\n// the java.util.Date will serialized to epoch, the Serialization will be covered later\r\n\r\njedi.delete(book); //see-ya, or you may need jedi.delete(Book.class, book.getId());\r\n\r\n```\r\n\r\n### Directly talk to redis\r\n\r\n```java\r\njedi.withJedis(new JedisCallback() {\r\n    public void execute(Jedis jedis) {\r\n        //automatic jedis pool resource managment like JdbcTemplate does\r\n    }\r\n\r\n});\r\n```\r\nor\r\n\r\n```java\r\njedi.withTransaction(new TransactionCallback() {\r\n    public void execute(Transaction transaction) {\r\n        //automatic transaltion start, commit and discard on exception\r\n    }\r\n});\r\n```\r\n\r\n\r\n###Index support\r\nLet's add some indexes to Book\r\n\r\n```java\r\n@Index(on = \"author\")\r\npublic class Book {\r\n   // \r\n}\r\n```\r\nThen we can find books by their author\r\n\r\n```java\r\nIterator<Book> booksOfRowling = jedis.find(Book.class).where(\"author\").is(\"J.K.Rowling\").iterate(0, 1);\r\n```\r\nindex rebuild is still in working progress. So for now, the **old objects will not be indexed**.\r\n\r\n###Range support\r\n\r\n```java\r\n@Index(on = \"author\", range = \"publishedAt\")\r\npublic class Book {\r\n    //\r\n}\r\n```\r\nThen you can find books by author and its published date\r\n\r\n```java\r\nIterator<Book> booksOfRowlingAfter2001 = jedis.find(Book.class)\r\n                                            .where(\"author\")\r\n                                                .is(\"J.K.Rowling\")\r\n                                            .andRange(\"publishedAt\")\r\n                                                .within(date2001InEpoch, Double.MAX_VALUE);\r\n```\r\nIf you need to index author both in published date range and some other fields, you should declare it like: \r\n\r\n```java\r\n@Indexes(\r\n    {\r\n        @Index(on = \"author\", range = \"publishedAt\"),\r\n        @Index(on = \"author\", range = \"someOtherField\")\r\n    }\r\n)\r\npublic class Book {\r\n    //\r\n}\r\n```\r\n###Multi fields index support\r\nSo what to do if we want to find books by its author and its title?\r\n\r\n```java\r\n@Index(on = {\"author\", \"title\"})\r\n//or you may prefer @Index(on = \"author, title\")\r\npublic class Book {\r\n    //\r\n}\r\n```\r\nThen you can find them like: \r\n\r\n```java\r\njedi.find(Book.class).where(\"author\").is(\"J.K.Rowling\").and(\"title\").is(\"Harry Potter\").iterator(0, 1);\r\n```\r\nMaybe we should add some method like _fetchOne_ for unique index?\r\n#Serialization\r\nThe java object will be converted to String based hash, then perisist to redis.\r\nfor now jedi supports types:\r\n\r\n* All basic primitive types and their wrappers\r\n* java.util.Date\r\n* String of couse\r\n\r\nYou can implemated your own StringSerializer, and register it using:\r\n\r\n```java\r\nStringSerializers.regiser(yourType, yourSerializer);\r\n```\r\n","tagline":"A simple persistence library for redis","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}